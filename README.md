Окей, зроблю для GitHub README файл у зрозумілому та структурованому вигляді на основі твоєї інформації та доповню його потрібними розділами.

---

# Лабораторна робота №2 — Інтерфейси, Наслідування, Агрегація в C++

## Мета роботи

Навчитися працювати з:

* Інтерфейсами у C++
* Наслідуванням між інтерфейсами та класами
* Агрегацією як відношенням "частина-ціле"
* UML-діаграмами для моделювання структури коду

---

## Що зроблено

* Створено інтерфейси: `If1`, `If2`, `If3` з методами `meth1()`, `meth2()`, `meth3()` відповідно
* Реалізовано три класи: `Cl1`, `Cl2`, `Cl3`, які реалізують відповідні інтерфейси
* Встановлено зв’язки:

  * Наслідування між інтерфейсами: `If3 ← If2 ← If1`
  * Наслідування між класами: `Cl1 ← Cl3`
  * Реалізація інтерфейсів класами
  * Агрегація: клас `Aggregation` містить об’єкти `Cl1`, `Cl2`, `Cl3`

---

## Пояснення виводу програми

```
Cl1::meth1()
Cl2::meth2()
Cl3::meth3()
```

* У `main()` створюємо по одному об'єкту кожного класу
* Передаємо ці об’єкти у `Aggregation` — демонструючи агрегацію
* Метод `Aggregation::show()` викликає:

  ```cpp
  cl1->meth1();
  cl2->meth2();
  cl3->meth3();
  ```
* Кожен метод виводить відповідний рядок, що демонструє роботу інтерфейсів і зв’язків

---

## Ключові концепції

| Концепція      | Що показує                                     | Приклад у проекті                              |
| -------------- | ---------------------------------------------- | ---------------------------------------------- |
| Інтерфейс      | Контракт, який клас повинен реалізувати        | `If1::meth1()`, `If2::meth2()`, `If3::meth3()` |
| Наслідування   | Узагальнення класів чи інтерфейсів             | `If3 ← If2 ← If1`, `Cl1 ← Cl3`                 |
| Реалізація     | Клас підписується на контракт інтерфейсу       | `Cl1` реалізує `If1`, `Cl2` — `If2` тощо       |
| Агрегація      | Відношення "частина-ціле", об’єкт містить інші | `Aggregation` містить `Cl1`, `Cl2`, `Cl3`      |
| Виклик методів | Демонстрація роботи зв’язків у коді            | В методі `show()` викликаються методи об’єктів |

---

## UML-діаграми

### 1. Діаграма класів (Class Diagram)

Відображає структуру класів, інтерфейсів та зв’язки:

* Наслідування (порожній трикутник ▲)
* Реалізація (пунктирна стрілка з трикутником)
* Агрегація (порожній ромб ◇)

### 2. Діаграма послідовностей (Sequence Diagram)

Показує порядок викликів:

* `main()` → `Aggregation::show()` → виклики методів `Cl1::meth1()`, `Cl2::meth2()`, `Cl3::meth3()`

### 3. Діаграма прецедентів (Use Case Diagram)

Показує зовнішні дії користувача:

* Користувач запускає програму
* Ініціалізує об’єкти
* Викликає `show()`
* Програма виконує методи класів

---

## Приклад коду

```cpp
// Інтерфейс If1
class If1 {
public:
    virtual void meth1() = 0;
    virtual ~If1() {}
};

// Клас Cl1 реалізує If1
class Cl1 : public If1 {
public:
    void meth1() override { std::cout << "Cl1::meth1()" << std::endl; }
};

// Аналогічно для If2, If3 і класів Cl2, Cl3

// Клас Aggregation демонструє агрегацію
class Aggregation {
    If1* cl1;
    If2* cl2;
    If3* cl3;
public:
    Aggregation(If1* c1, If2* c2, If3* c3) : cl1(c1), cl2(c2), cl3(c3) {}
    void show() {
        cl1->meth1();
        cl2->meth2();
        cl3->meth3();
    }
};
```

---

## Висновок

Лабораторна робота не про складний вивід, а про розуміння принципів ООП:

* Як інтерфейси визначають контракти
* Як класи їх реалізують
* Як зв’язки (наслідування, агрегація) моделюються у UML і працюють у коді
* Як зв’язати об’єкти у складну структуру

